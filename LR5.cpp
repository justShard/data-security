#include <string>

// Функція для кодування тексту у бітову строку за допомогою повторення бітів
std::string encode(std::string text)
{
  std::string ret; // Результат кодування
  for (char ch : text) { // Проходимо кожен символ тексту
    bool ds[8]; // Масив для збереження біта кожної позиції символу (1 байт = 8 бітів)
    for (int i = 0; i < 8; ++i) {
      ds[i] = ch % 2; // Визначаємо найменший біт символу
      ch /= 2; // Зсуваємо біти праворуч для аналізу наступного біту
    }
    // Тепер кожен біт повторюється тричі для кодування
    for (int i = 7; i >= 0; --i) { // Обробляємо біти у зворотному порядку
      if (ds[i]) ret += "111"; // Якщо біт 1, додаємо "111"
      else ret += "000"; // Якщо біт 0, додаємо "000"
    }
  }
  return ret; // Повертаємо результат у вигляді закодованої строки
}

// Функція для декодування бітової строки назад у текст
std::string decode(std::string bits)
{
  std::string ret; // Результат декодування
  bool ds[8] = {0}; // Масив для збереження 8 бітів символу
  for (int i = 0; i < bits.length(); i += 3) { // Читаємо кожні три біти
    int counts[2] = {0}; // Лічильник для підрахунку кількості 0 і 1 у трьох бітах
    for (int j = i; j < i + 3; ++j) { // Підраховуємо кількість 0 і 1
      counts[bits[j] - '0']++;
    }
    // idx визначає позицію біта у байті (символі)
    int idx = (i % 24) / 3;
    // Якщо є більше або рівно два 1, то вважаємо біт 1, інакше 0
    ds[idx] = counts[1] >= 2;
    if (idx == 7) { // Коли зібрано 8 бітів, перетворюємо їх у символ
      char ch = 0;
      for (int j = 0; j < 8; ++j) {
        ch *= 2; ch += ds[j] ? 1 : 0; // Формуємо символ зі збережених бітів
      }
      ret += ch; // Додаємо символ до результату
    }
  }
  return ret; // Повертаємо декодовану строку
}
