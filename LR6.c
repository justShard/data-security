const char *scanner (int q[21][21]) {
  // Статична змінна для збереження результату. Статична, щоб результат не був знищений після завершення функції
  static char m[10]; 
  int b=0,      // Проміжна змінна для формування байта даних
      x=20,     // Початкова координата по осі X
      y=19,     // Початкова координата по осі Y
      i=0,      // Індекс для зберігання результатів у масив m
      c=1,      // Лічильник для операцій із бітами
      e=1;      // Перемінна для чергування стану
  
  // Перший цикл обробляє область зверху вниз від y=19 до y=9, коли y>8
  while (--y > 8) 
    b |= !e^q[y][x-1] | (e^q[y][x])*2,  // Формування частини байта на основі значень з масиву q
    c++%4 ? 0 : (m[i++] = b),           // Кожні 4 кроки зберігаємо значення b у m[i]
    b <<= 2,                            // Зсув значення b ліворуч на 2 біти
    e ^= 1;                             // Інверсія стану e (чергування)
  e ^= 1,                               // Ще раз інвертуємо e
  x -= 2;                               // Зменшуємо x на 2

  // Другий цикл обробляє область знизу вверх від y=9 до y=20
  while (++y < 21)
    b |= !e^q[y][x-1] | (e^q[y][x])*2,  // Аналогічно формуємо байти, рухаючись в протилежному напрямку
    c++%4 ? 0 : (m[i++] = b),           // Кожні 4 кроки зберігаємо значення b у m[i]
    b <<= 2,                            // Зсув значення b
    e ^= 1;                             // Чергування стану e
  e ^= 1,                               // Ще раз інвертуємо e
  x -= 2;                               // Зменшуємо x на 2

  // Третій цикл знову зменшує y, рухаючись від y=20 до y=11
  while (y-- > 11)
    b |= !e^q[y][x-1] | (e^q[y][x])*2,  // Формуємо байти даних
    c++%4 ? 0 : (m[i++] = b),           // Кожні 4 кроки зберігаємо значення
    b <<= 2,                            // Зсув b ліворуч
    e ^= 1;                             // Чергування стану e

  // Завершення функції: встановлюємо завершення строки та повертаємо вказівник на результуючий масив
  return m[1 + m[0]] = 0, m + 1;
}
